# sleigh include file for NEC 78K0 language instructions

#########################
##  Tokens and Fields  ##
#########################

define token inst8(8)
	op8_full   		= (0, 7)
	op8_37     		= (3, 7)
	op8_02			= (0, 2)
	op8_02_reg 		= (0, 2)
	op8_12			= (1, 2)
	op8_12_reg		= (1, 2)
	op8_0			= (0, 0)
	op8_67			= (6, 7)
	op8_51_addr		= (1, 5)
;

define token inst16(16)
	op16_37			= (3, 7)
	op16_02			= (0, 2)
	op16_02_reg		= (0, 2)
	op16_815 		= (8, 15)
	op16_815_signed	= (8, 15) signed
	op16_07  		= (0, 7)
	op16_1115		= (11, 15)
	op16_810_reg	= (8, 10)
	op16_811		= (8, 11)
	op16_1515		= (15, 15)
	op16_1214		= (12, 14)
	op16_7			= (7, 7)
	op16_46			= (4, 6)
	op16_03			= (0, 3)
	op16_0			= (0, 0)
	op16_11			= (11, 11)
	op16_810		= (8, 10)
	op16_12			= (12, 12)
	op16_1415		= (14, 15)
	op16_13			= (13, 13)
;

define token inst24(24)
	op24_07			= (0, 7)
	op24_815		= (8, 15)
	op24_1623		= (16, 23)
	op24_1623_signed= (16, 23) signed
	op24_12_reg 	= (1, 2)
	op24_0			= (0, 0)
	op24_37			= (3, 7)
	op24_811		= (8, 11)
	op24_1515		= (15, 15)
	op24_1214		= (12, 14)
	op24_7			= (7, 7)
	op24_03			= (0, 3)
	op24_46			= (4, 6)
	op24_823_imm16	= (8, 23)
;

define token inst32(32)
	op32_07			= (0, 7)
	op32_815		= (8, 15)
	op32_1623		= (16, 23)
	op32_2431		= (24, 31)
	op32_2431_signed= (24, 31) signed
	op32_811		= (8, 11)
	op32_1515		= (15, 15)
	op32_1214		= (12, 14)
	op32_1631_imm16	= (16, 31)
;

#####################################
##  Register Variable Attachments  ##
#####################################

# 8-bit Registers (r)
attach variables [ op8_02_reg op16_02_reg op16_810_reg ] [
	X A C B E D L H
];

# 16-bit (Word) Registers (rp)
attach variables [ op8_12_reg op24_12_reg ] [
	AX BC DE HL
];

#########################
##  Pseudo Operations  ##
#########################

define pcodeop halt;
define pcodeop stop;
define pcodeop enableInterrupts;
define pcodeop disableInterrupts;

##############################
##  Operand Display Tables  ##
##############################

CY:	"CY" is epsilon { }
PSW_Ref: "PSW" is epsilon { }

######################
##  Address Tables  ##
######################

abs16: op24_823_imm16 is op24_823_imm16 {
	export *:1 op24_823_imm16;
}

abs16p: op24_823_imm16 is op24_823_imm16 {
	export *:2 op24_823_imm16;
}

rel8: addr is op16_815 [addr = inst_next + op16_815; ] {
	export *:1 addr;
}

rel8_1623: addr is op24_1623 [addr = inst_next + op24_1623; ] {
	export *:1 addr;
}

rel8_2431: addr is op32_2431 [addr = inst_next + op32_2431; ] {
	export *:1 addr;
}

saddr16low: addr is op16_815 [addr = 0xFE00 + op16_815;] {
	export *:1 addr;
}

saddr16lowp: addr is op16_815 [addr = 0xFE00 + op16_815;] {
	export *:2 addr;
}

saddr24low: addr is op24_815 [addr = 0xFE00 + op24_815;] {
	export *:1 addr;
}

saddr24low_1623: addr is op24_1623 [addr = 0xFE00 + op24_1623;] {
	export *:1 addr;
}

saddr32low: addr is op32_815 [addr = 0xFE00 + op32_815;] {
	export *:1 addr;
}

saddr32lowp: addr is op32_815 [addr = 0xFE00 + op32_815;] {
	export *:2 addr;
}

saddr32low_1623: addr is op32_1623 [addr = 0xFE00 + op32_1623;] {
	export *:1 addr;
}

saddr16high: addr is op16_815 [addr = 0xFF00 + op16_815;] {
	export *:1 addr;
}

saddr16highp: addr is op16_815 [addr = 0xFF00 + op16_815;] {
	export *:2 addr;
}

saddr24high: addr is op24_815 [addr = 0xFF00 + op24_815;] {
	export *:1 addr;
}

saddr24high_1623: addr is op24_1623 [addr = 0xFF00 + op24_1623;] {
	export *:1 addr;
}

saddr32high: addr is op32_815 [addr = 0xFF00 + op32_815;] {
	export *:1 addr;
}

saddr32highp: addr is op32_815 [addr = 0xFF00 + op32_815;] {
	export *:2 addr;
}

saddr32high_1623: addr is op32_1623 [addr = 0xFF00 + op32_1623;] {
	export *:1 addr;
}

sfr16: addr is op16_815 [addr = 0xFF00 + op16_815;] {
	export *:1 addr;
}

sfr16p: addr is op16_815 [addr = 0xFF00 + op16_815;] {
	export *:2 addr;
}

sfr24: addr is op24_815 [addr = 0xFF00 + op24_815;] {
	export *:1 addr;
}

sfr24_1623: addr is op24_1623 [addr = 0xFF00 + op24_1623;] {
	export *:1 addr;
}

sfr32: addr is op32_815 [addr = 0xFF00 + op32_815;] {
	export *:1 addr;
}

sfr32p: addr is op32_815 [addr = 0xFF00 + op32_815;] {
	export *:2 addr;
}

sfr32_1623: addr is op32_1623 [addr = 0xFF00 + op32_1623;] {
	export *:1 addr;
}

## Rel8 With 2's Complement offset
# 
jdisp8: addr is op16_815_signed [addr = inst_next + op16_815_signed; ] {
	export *:1 addr;
}

jdisp8_1623: addr is op24_1623_signed [addr = inst_next + op24_1623_signed; ] {
	export *:1 addr;
}

jdisp8_2431: addr is op32_2431_signed [addr = inst_next + op32_2431_signed; ] {
	export *:1 addr;
}

##############
##  Macros  ##
##############

macro push8(val8) {
	SP = SP - 1;
	local ptr:1 = SP:1;
	*:1 ptr = val8:1;
}

macro pop8(ret8) {
	local ptr:1 = SP:1;
	ret8 = *:1 ptr;
	SP = SP + 1;
}

macro push16(val16) {
	SP = SP - 2;
	local ptr:2 = SP:2;
	*:2 ptr = val16;
}

macro pop16(ret16) {
	local ptr:2 = SP:2;
	ret16 = *:2 ptr;
	SP = SP + 2;
}
####################
##  Instructions  ##
####################

## 8-Bit Data Transfer Instructions

# Instruction: MOV
# Format: MOV r, #byte
# Description: Byte Data Transfer
# Addressing Mode: Register

:MOV op16_02_reg, op16_815 is op16_37 = 0b10100 & op16_02_reg & op16_815 {
	op16_02_reg = op16_815;
}

# Instruction: MOV
# Format: MOV saddr, #byte
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:MOV saddr24low, op24_1623 is op24_07 = 0b00010001 & op24_815 >= 0x20 & op24_815 & op24_1623 & saddr24low {
	saddr24low = op24_1623;
}

:MOV saddr24high, op24_1623 is op24_07 = 0b00010001 & op24_815 < 0x20 & op24_815 != 0x1E & op24_815 & op24_1623 & saddr24high {
	saddr24high = op24_1623;
}

# Instruction: MOV
# Format: MOV sfr, #byte
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW overlap.
:MOV sfr24, op24_1623 is op24_07 = 0b00010011 & ((op24_815 >= 0x00 & op24_815 <= 0xCF & op24_815 != 0x1E) | (op24_815 >= 0xE0 & op24_815 <= 0xFF)) & op24_815 & op24_1623 & sfr24 {
	sfr24 = op24_1623;
}

# Instruction: MOV
# Format: MOV A, r
# Description: Byte Data Transfer
# Addressing Mode: Register
:MOV A, op8_02_reg is op8_37 = 0b01100 & op8_02 != 0b001 & op8_02_reg & A {
	A = op8_02_reg;
}

# Instruction: MOV
# Format: MOV r, A
# Description: Byte Data Transfer
# Addressing Mode: Register
:MOV op8_02_reg, A is op8_37 = 0b01110 & op8_02 != 0b001 & op8_02_reg & A {
	op8_02_reg = A;
}

# Instruction: MOV
# Format: MOV A, saddr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:MOV A, saddr16low is op16_07 = 0b11110000 & op16_815 >= 0x20 & op16_815 & A & saddr16low {
	A = saddr16low:1;
}

:MOV A, saddr16high is op16_07 = 0b11110000 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & A & saddr16high {
	A = saddr16high:1;
}

# Instruction: MOV
# Format: MOV saddr, A
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:MOV saddr16low, A is op16_07 = 0b11110010 & op16_815 >= 0x20 & op16_815 & A & saddr16low {
	saddr16low = A;
}

:MOV saddr16high, A is op16_07 = 0b11110010 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & A & saddr16high {
	saddr16high = A;
}

# Instruction: MOV
# Format: MOV A, sfr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW overlap.
:MOV A, sfr16 is op16_07 = 0b11110100 & ((op16_815 >= 0x00 & op16_815 <= 0xCF & op16_815 != 0x1E) | (op16_815 >= 0xE0 & op16_815 <= 0xFF)) & op16_815 & A & sfr16 {
	A = sfr16:1;
}

# Instruction: MOV
# Format: MOV sfr, A
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW overlap.
:MOV sfr16, A is op16_07 = 0b11110110 & ((op16_815 >= 0x00 & op16_815 <= 0xCF & op16_815 != 0x1E) | (op16_815 >= 0xE0 & op16_815 <= 0xFF)) & op16_815 & A & sfr16 {
	sfr16 = A;
}

# Instruction: MOV
# Format: MOV A, !addr16
# Description: Byte Data Transfer
# Addressing Mode: Register
:MOV A, !abs16 is op24_07 = 0b10001110 & op24_815 & op24_1623 & A & abs16 {
	A = abs16:1;
}

# Instruction: MOV
# Format: MOV !addr16, A
# Description: Byte Data Transfer
# Addressing Mode: Register
:MOV !abs16, A is op24_07 = 0b10011110 & op24_815 & op24_1623 & A & abs16 {
	abs16 = A;
}

# Instruction: MOV
# Format: MOV PSW, #byte
# Description: Byte Data Transfer
# Addressing Mode: Register
:MOV PSW_Ref, op24_1623 is op24_07 = 0b00010001 & op24_815 = 0b00011110 & op24_1623 & PSW_Ref {
	# No interrupts are handled during this procedure.
	PSW = op24_1623;
}

# Instruction: MOV
# Format: MOV A, PSW
# Description: Byte Data Transfer
# Addressing Mode: Register
:MOV A, PSW_Ref is op16_07 = 0b11110000 & op16_815 = 0b00011110 & A & PSW_Ref {
	A = PSW;
}

# Instruction: MOV
# Format: MOV PSW, A
# Description: Byte Data Transfer
# Addressing Mode: Register
:MOV PSW_Ref, A is op16_07 = 0b11110010 & op16_815 = 0b00011110 & A & PSW_Ref {
	# No interrupts are handled during this procedure.
	PSW = A;
}

# Instruction: MOV
# Format: MOV A, [DE]
# Description: Byte Data Transfer
# Addressing Mode: Direct
:MOV A, [DE] is op8_full = 0b10000101 & A & DE {
	A = *DE;
}

# Instruction: MOV
# Format: MOV [DE], A
# Description: Byte Data Transfer
# Addressing Mode: Direct
:MOV [DE], A is op8_full = 0b10010101 & A & DE {
	*DE = A;
}

# Instruction: MOV
# Format: MOV A, [HL]
# Description: Byte Data Transfer
# Addressing Mode: Direct
:MOV A, [HL] is op8_full = 0b10000111 & A & HL {
	A = *HL;
}

# Instruction: MOV
# Format: MOV [HL], A
# Description: Byte Data Transfer
# Addressing Mode: Direct
:MOV [HL], A is op8_full = 0b10010111 & A & HL {
	*HL = A;
}

# Instruction: MOV
# Format: MOV A, [HL + byte]
# Description: Byte Data Transfer
# Addressing Mode: Direct
:MOV A, [HL + op16_815] is op16_07 = 0b10101110 & A & HL & op16_815 {
	A = *(&HL + op16_815);
}

# Instruction: MOV
# Format: MOV [HL + byte], A
# Description: Byte Data Transfer
# Addressing Mode: Direct
:MOV [HL + op16_815], A is op16_07 = 0b10111110 & A & HL & op16_815 {
	*(&HL + op16_815) = A;
}

# Instruction: MOV
# Format: MOV A, [HL + B]
# Description: Byte Data Transfer
# Addressing Mode: Direct
:MOV A, [HL + B] is op8_full = 0b10101011 & A & HL & B {
	A = *(&HL + &B);
}

# Instruction: MOV
# Format: MOV [HL + B], A
# Description: Byte Data Transfer
# Addressing Mode: Direct
:MOV [HL + B], A is op8_full = 0b10111011 & A & HL & B {
	*(&HL + &B) = A;
}

# Instruction: MOV
# Format: MOV A, [HL + C]
# Description: Byte Data Transfer
# Addressing Mode: Direct
:MOV A, [HL + C] is op8_full = 0b10101010 & A & HL & C {
	A = *(&HL + &C);
}

# Instruction: MOV
# Format: MOV [HL + C], A
# Description: Byte Data Transfer
# Addressing Mode: Direct
:MOV [HL + C], A is op8_full = 0b10111010 & A & HL & C {
	*(&HL + &C) = A;
}



# Instruction: XCH
# Format: XCH A, r
# Description: Byte Data Exchange
# Addressing Mode: Register
:XCH A, op8_02_reg is op8_37 = 0b00110 & op8_02 != 0b001 & op8_02_reg & A {
	local temp = A;
	A = op8_02_reg;
	op8_02_reg = temp;
}

# Instruction: XCH
# Format: XCH A, saddr
# Description: Byte Data Exchange
# Addressing Mode: Short Direct
:XCH A, saddr16low is op16_07 = 0b10000011 & op16_815 >= 0x20 & op16_815 & A & saddr16low {
	local temp = A;
	A = saddr16low;
	saddr16low = temp;
}
:XCH A, saddr16high is op16_07 = 0b10000011 & op16_815 < 0x20 & op16_815 & A & saddr16high {
	local temp = A;
	A = saddr16high;
	saddr16high = temp;
}

# Instruction: XCH
# Format: XCH A, sfr
# Description: Byte Data Exchange
# Addressing Mode: Short Direct
:XCH A, sfr16 is op16_07 = 0b10010011 & ((op16_815 >= 0x00 & op16_815 <= 0xCF) | (op16_815 >= 0xE0 & op16_815 <= 0xFF)) & op16_815 & A & sfr16 {
	local temp = A;
	A = sfr16;
	sfr16 = temp;
}

# Instruction: XCH
# Format: XCH A, !addr16
# Description: Byte Data Transfer
# Addressing Mode: Register
:XCH A, !abs16 is op24_07 = 0b11001110 & op24_815 & op24_1623 & A & abs16 {
	local temp = A;
	A = abs16;
	abs16 = temp;
}

# Instruction: XCH
# Format: XCH A, [DE]
# Description: Byte Data Exchange
# Addressing Mode: Direct
:XCH A, [DE] is op8_full = 0b00000101 & A & DE {
	local temp = A;
	A = *DE;
	*DE = temp;
}

# Instruction: XCH
# Format: XCH A, [HL]
# Description: Byte Data Exchange
# Addressing Mode: Direct
:XCH A, [HL] is op8_full = 0b00000111 & A & HL {
	local temp = A;
	A = *HL;
	*HL = temp;
}

# Instruction: XCH
# Format: XCH A, [HL + byte]
# Description: Byte Data Exchange
# Addressing Mode: Direct
:XCH A, [HL + op16_815] is op16_07 = 0b11011110 & op16_815 & A & HL {
	local temp = A;
	A = *(&HL + op16_815);
	*(&HL + &op16_815) = temp;
}

# Instruction: XCH
# Format: XCH A, [HL + B]
# Description: Byte Data Exchange
# Addressing Mode: Direct
:XCH A, [HL + B] is op16_07 = 0b00110001 & op16_815 = 0b10001011 & A & HL & B {
	local temp = A;
	A = *(&HL + &B);
	*(&HL + &B) = temp;
}

# Instruction: XCH
# Format: XCH A, [HL + C]
# Description: Byte Data Exchange
# Addressing Mode: Direct
:XCH A, [HL + C] is op16_07 = 0b00110001 & op16_815 = 0b10001010 & A & HL & C {
	local temp = A;
	A = *(&HL + &C);
	*(&HL + &C) = temp;
}



## 16-Bit Data Transfer Instructions

# Instruction: MOVW
# Format: MOVW rp, #word
# Description: Word Data Transfer
# Addressing Mode: Register
:MOVW op24_12_reg, "#"op24_823_imm16 is op24_37 = 0b00010 & op24_0 = 0b0 & op24_12_reg & op24_823_imm16 {
	op24_12_reg = op24_823_imm16;
}

# Instruction: MOVW
# Format: MOVW saddrp, #word
# Description: Word Data Transfer
# Note: Condition added here to prevent PSW and SP instruction overlap.
:MOVW saddr32lowp, "#"op32_1631_imm16 is op32_07 = 0b11101110 & op32_815 >= 0x20 & op32_815 & op32_1631_imm16 & saddr32lowp {
	saddr32lowp = op32_1631_imm16;
}
:MOVW saddr32highp, "#"op32_1631_imm16 is op32_07 = 0b11101110 & op32_815 < 0x20 & op32_815 != 0x1C & op32_815 & op32_1631_imm16 & saddr32highp {
	saddr32highp = op32_1631_imm16;
}

# Instruction: MOVW
# Format: MOVW sfrp, #word
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
:MOVW sfr32p, "#"op32_1631_imm16 is op32_07 = 0b11111110 & ((op32_815 >= 0x00 & op32_815 <= 0xCF) | (op32_815 >= 0xE0 & op32_815 <= 0xFF)) & op32_815 & op32_1631_imm16 & sfr32p {
	sfr32p = op32_1631_imm16;
}

# Instruction: MOVW
# Format: MOVW AX, saddrp
# Description: Word Data Transfer
# Note: Condition added here to prevent PSW and SP instruction overlap.
:MOVW AX, saddr16lowp is op16_07 = 0b10001001 & op16_815 >= 0x20 & op16_815 & AX & saddr16lowp {
	AX = saddr16lowp:2;
}
:MOVW AX, saddr16highp is op16_07 = 0b10001001 & op16_815 < 0x20 & op16_815 != 0x1C & op16_815 & AX & saddr16highp {
	AX = saddr16highp:2;
}

# Instruction: MOVW
# Format: MOVW saddrp, AX
# Description: Word Data Transfer
# Note: Condition added here to prevent PSW and SP instruction overlap.
:MOVW saddr16lowp, AX is op16_07 = 0b10011001 & op16_815 >= 0x20 & op16_815 & AX & saddr16lowp {
	saddr16lowp = AX;
}
:MOVW saddr16highp, AX is op16_07 = 0b10011001 & op16_815 < 0x20 & op16_815 != 0x1C & op16_815 & AX & saddr16highp {
	saddr16highp = AX;
}

# Instruction: MOVW
# Format: MOVW AX, sfrp
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
:MOVW AX, sfr16p is op16_07 = 0b10101001 & ((op16_815 >= 0x00 & op16_815 <= 0xCF) | (op16_815 >= 0xE0 & op16_815 <= 0xFF)) & op16_815 & AX & sfr16p {
	AX = sfr16p;
}

# Instruction: MOVW
# Format: MOVW sfrp, AX
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
:MOVW sfr16p, AX is op16_07 = 0b10111001 & ((op16_815 >= 0x00 & op16_815 <= 0xCF) | (op16_815 >= 0xE0 & op16_815 <= 0xFF)) & op16_815 & AX & sfr16p {
	sfr16p = AX;
}

# Instruction: MOVW
# Format: MOVW AX, rp
# Description: Word Data Transfer
# Addressing Mode: Register
:MOVW AX, op8_12_reg is op8_37 = 0b11000 & op8_0 = 0b0 & op8_12 != 0b0 & op8_12_reg & AX {
	AX = op8_12_reg;
}

# Instruction: MOVW
# Format: MOVW rp, AX
# Description: Word Data Transfer
# Addressing Mode: Register
:MOVW op8_12_reg, AX is op8_37 = 0b11010 & op8_0 = 0b0 & op8_12 != 0b0 & op8_12_reg & AX {
	op8_12_reg = AX;
}

# Instruction: MOVW
# Format: MOVW AX, !addr16
# Description: Word Data Transfer
# Addressing Mode: Register
:MOVW AX, !abs16p is op24_07 = 0b00000010 & op24_815 & op24_1623 & AX & abs16p {
	AX = abs16p;
}

# Instruction: MOVW
# Format: MOVW !addr16, AX
# Description: Word Data Transfer
# Addressing Mode: Register
:MOVW !abs16p, AX is op24_07 = 0b00000011 & op24_815 & op24_1623 & AX & abs16p {
	abs16p = AX;
}



# Instruction: XCHW
# Format: XCHW AX, rp
# Description: Word Data Exchange
# Addressing Mode: Register
:XCHW AX, op8_12_reg is op8_37 = 0b11100 & op8_0 = 0b0 & op8_12 != 0b0 & op8_12_reg & AX {
	local temp = AX;
	AX = op8_12_reg;
	op8_12_reg = temp;
}



## 8-Bit Operation Instructions

# Instruction: ADD
# Format: ADD A, #byte
# Description: Byte Data Addition
# Addressing Mode: Register
:ADD A, "#"op16_815 is op16_07 = 0b00001101 & op16_815 & A {
	A = A + op16_815;
}

# Instruction: ADD
# Format: ADD saddr, #byte
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:ADD saddr24low, "#"op24_1623 is op24_07 = 0b10001000 & op24_815 >= 0x20 & op24_815 & op24_1623 & saddr24low {
	saddr24low = saddr24low + op24_1623;
}
:ADD saddr24high, "#"op24_1623 is op24_07 = 0b10001000 & op24_815 < 0x20 & op24_815 != 0x1E & op24_815 & op24_1623 & saddr24high {
	saddr24high = saddr24high + op24_1623;
}

# Instruction: ADD
# Format: ADD A, r
# Description: Byte Data Addition
# Addressing Mode: Register
:ADD A, op16_810_reg is op16_07 = 0b01100001 & op16_1115 = 0b00001 & op16_810 != 0b001 & op16_810_reg & A {
	A = A + op16_810_reg;
}

# Instruction: ADD
# Format: ADD r, A
# Description: Byte Data Addition
# Addressing Mode: Register
:ADD op16_810_reg, A is op16_07 = 0b01100001 & op16_1115 = 0b00000 & op16_810_reg & A {
	op16_810_reg = op16_810_reg + A;
}

# Instruction: ADD
# Format: ADD A, saddr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:ADD A, saddr16low is op16_07 = 0b00001110 & op16_815 >= 0x20 & op16_815 & A & saddr16low {
	A = A + saddr16low;
}
:ADD A, saddr16high is op16_07 = 0b00001110 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & A & saddr16high {
	A = A + saddr16high;
}

# Instruction: ADD
# Format: ADD A, !addr16
# Description: Byte Data Addition
# Addressing Mode: Register
:ADD A, "!"abs16 is op24_07 = 0b00001000 & op24_815 & op24_1623 & A & abs16 {
	A = A + abs16;
}

# Instruction: ADD
# Format: ADD A, [HL]
# Description: Byte Data Addition
# Addressing Mode: Register
:ADD A, [HL] is op8_full = 0b00001111 & A & HL {
	A = A + *HL;
}

# Instruction: ADD
# Format: ADD A, [HL+byte]
# Description: Byte Data Addition
# Addressing Mode: Register
:ADD A, [HL + op16_815] is op16_07 = 0b00001001 & op16_815 & A & HL {
	A = A + *(HL + op16_815);
}

# Instruction: ADD
# Format: ADD A, [HL+B]
# Description: Byte Data Addition
# Addressing Mode: Register
:ADD A, [HL + B] is op16_07 = 0b00110001 & op16_815 = 0b00001011 & A & HL & B {
	A = A + *(&HL + &B);
}

# Instruction: ADD
# Format: ADD A, [HL+C]
# Description: Byte Data Addition
# Addressing Mode: Register
:ADD A, [HL + C] is op16_07 = 0b00110001 & op16_815 = 0b00001010 & A & HL & C {
	A = A + *(&HL + &C);
}



# Instruction: ADDC
# Format: ADDC A, #byte
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:ADDC A, "#"op16_815 is op16_07 = 0b00101101 & op16_815 & A {
	A = A + op16_815 + PSW[0, 1];
}

# Instruction: ADDC
# Format: ADDC saddr, #byte
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:ADDC saddr24low, "#"op24_1623 is op24_07 = 0b10101000 & op24_815 >= 0x20 & op24_815 & op24_1623 & saddr24low {
	saddr24low = saddr24low + op24_1623 + PSW[0, 1];
}
:ADDC saddr24high, "#"op24_1623 is op24_07 = 0b10101000 & op24_815 < 0x20 & op24_815 != 0x1E & op24_815 & op24_1623 & saddr24high {
	saddr24high = saddr24high + op24_1623 + PSW[0, 1];
}

# Instruction: ADDC
# Format: ADDC A, r
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:ADDC A, op16_810_reg is op16_07 = 0b01100001 & op16_1115 = 0b00101 & op16_810 != 0b001 & op16_810_reg & A {
	A = A + op16_810_reg + PSW[0, 1];
}

# Instruction: ADDC
# Format: ADDC r, A
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:ADDC op16_810_reg, A is op16_07 = 0b01100001 & op16_1115 = 0b00100 & op16_810_reg & A {
	op16_810_reg = op16_810_reg + A + PSW[0, 1];
}

# Instruction: ADDC
# Format: ADDC A, saddr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:ADDC A, saddr16low is op16_07 = 0b00101110 & op16_815 >= 0x20 & op16_815 & A & saddr16low {
	A = A + saddr16low + PSW[0, 1];
}
:ADDC A, saddr16high is op16_07 = 0b00101110 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & A & saddr16high {
	A = A + saddr16high + PSW[0, 1];
}

# Instruction: ADDC
# Format: ADDC A, !addr16
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:ADDC A, "!"abs16 is op24_07 = 0b00101000 & op24_815 & op24_1623 & A & abs16 {
	A = A + abs16 + PSW[0, 1];
}

# Instruction: ADDC
# Format: ADDC A, [HL]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:ADDC A, [HL] is op8_full = 0b00101111 & A & HL {
	A = A + *HL + PSW[0, 1];
}

# Instruction: ADDC
# Format: ADDC A, [HL+byte]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:ADDC A, [HL + op16_815] is op16_07 = 0b00101001 & op16_815 & A & HL {
	A = A + *(&HL + op16_815) + PSW[0, 1];
}

# Instruction: ADDC
# Format: ADDC A, [HL+B]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:ADDC A, [HL + B] is op16_07 = 0b00110001 & op16_815 = 0b00101011 & A & HL & B {
	A = A + *(&HL + &B) + PSW[0, 1];
}

# Instruction: ADDC
# Format: ADDC A, [HL+C]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:ADDC A, [HL + C] is op16_07 = 0b00110001 & op16_815 = 0b00101010 & A & HL & C {
	A = A + *(&HL + &C) + PSW[0, 1];
}



# Instruction: SUB
# Format: SUB A, #byte
# Description: Byte Data Subtraction
# Addressing Mode: Register
:SUB A, "#"op16_815 is op16_07 = 0b00011101 & op16_815 & A {
	A = A - op16_815;
}

# Instruction: SUB
# Format: SUB saddr, #byte
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:SUB saddr24low, "#"op24_1623 is op24_07 = 0b10011000 & op24_815 >= 0x20 & op24_815 & op24_1623 & saddr24low {
	saddr24low = saddr24low - op24_1623;
}
:SUB saddr24high, "#"op24_1623 is op24_07 = 0b10011000 & op24_815 < 0x20 & op24_815 != 0x1E & op24_815 & op24_1623 & saddr24high {
	saddr24high = saddr24high - op24_1623;
}

# Instruction: SUB
# Format: SUB A, r
# Description: Byte Data Subtraction
# Addressing Mode: Register
:SUB A, op16_810_reg is op16_07 = 0b01100001 & op16_1115 = 0b00011 & op16_810 != 0b001 & op16_810_reg & A {
	A = A - op16_810_reg;
}

# Instruction: SUB
# Format: SUB r, A
# Description: Byte Data Subtraction
# Addressing Mode: Register
:SUB op16_810_reg, A is op16_07 = 0b01100001 & op16_1115 = 0b00010 & op16_810_reg & A {
	op16_810_reg = op16_810_reg - A;
}

# Instruction: SUB
# Format: SUB A, saddr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:SUB A, saddr16low is op16_07 = 0b00011110 & op16_815 >= 0x20 & op16_815 & A & saddr16low {
	A = A - saddr16low;
}
:SUB A, saddr16high is op16_07 = 0b00011110 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & A & saddr16high {
	A = A - saddr16high;
}

# Instruction: SUB
# Format: SUB A, !addr16
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:SUB A, "!"abs16 is op24_07 = 0b00011000 & op24_815 & op24_1623 & A & abs16 {
	A = A - abs16;
}

# Instruction: SUB
# Format: SUB A, [HL]
# Description: Byte Data Subtraction
# Addressing Mode: Register
:SUB A, [HL] is op8_full = 0b00011111 & A & HL {
	A = A - *HL;
}

# Instruction: SUB
# Format: SUB A, [HL+byte]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:SUB A, [HL + op16_815] is op16_07 = 0b00011001 & op16_815 & A & HL {
	A = A - *(&HL + op16_815);
}

# Instruction: SUB
# Format: SUB A, [HL+B]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:SUB A, [HL + B] is op16_07 = 0b00110001 & op16_815 = 0b00011011 & A & HL & B {
	A = A - *(&HL - &B);
}

# Instruction: SUB
# Format: SUB A, [HL+C]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:SUB A, [HL + C] is op16_07 = 0b00110001 & op16_815 = 0b00011010 & A & HL & C {
	A = A - *(&HL - &C);
}



# Instruction: SUBC
# Format: SUBC A, #byte
# Description: Byte Data Subtraction
# Addressing Mode: Register
:SUBC A, "#"op16_815 is op16_07 = 0b00111101 & op16_815 & A {
	A = A - op16_815 - PSW[0, 1];
}

# Instruction: SUBC
# Format: SUBC saddr, #byte
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:SUBC saddr24low, "#"op24_1623 is op24_07 = 0b10111000 & op24_815 >= 0x20 & op24_815 & op24_1623 & saddr24low {
	saddr24low = saddr24low - op24_1623 - PSW[0, 1];
}
:SUBC saddr24high, "#"op24_1623 is op24_07 = 0b10111000 & op24_815 < 0x20 & op24_815 != 0x1E & op24_815 & op24_1623 & saddr24high {
	saddr24high = saddr24high - op24_1623 - PSW[0, 1];
}

# Instruction: SUBC
# Format: SUBC A, r
# Description: Byte Data Subtraction
# Addressing Mode: Register
:SUBC A, op16_810_reg is op16_07 = 0b01100001 & op16_1115 = 0b00111 & op16_810 != 0b001 & op16_810_reg & A {
	A = A - op16_810_reg - PSW[0, 1];
}

# Instruction: SUBC
# Format: SUBC r, A
# Description: Byte Data Subtraction
# Addressing Mode: Register
:SUBC op16_810_reg, A is op16_07 = 0b01100001 & op16_1115 = 0b00110 & op16_810_reg & A {
	op16_810_reg = op16_810_reg - A - PSW[0, 1];
}

# Instruction: SUBC
# Format: SUBC A, saddr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:SUBC A, saddr16low is op16_07 = 0b00111110 & op16_815 >= 0x20 & op16_815 & A & saddr16low {
	A = A - saddr16low - PSW[0, 1];
}
:SUBC A, saddr16high is op16_07 = 0b00111110 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & A & saddr16high {
	A = A - saddr16high - PSW[0, 1];
}

# Instruction: SUBC
# Format: SUBC A, !addr16
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:SUBC A, "!"abs16 is op24_07 = 0b00111000 & op24_815 & op24_1623 & A & abs16 {
	A = A - abs16 - PSW[0, 1];
}

# Instruction: SUBC
# Format: SUBC A, [HL]
# Description: Subtraction of Byte Data with Carry
# Addressing Mode: Register
:SUBC A, [HL] is op8_full = 0b00111111 & A & HL {
	A = A - *HL - PSW[0, 1];
}

# Instruction: SUBC
# Format: SUBC A, [HL+byte]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:SUBC A, [HL + op16_815] is op16_07 = 0b00111001 & op16_815 & A & HL {
	A = A - *(&HL + op16_815) - PSW[0, 1];
}

# Instruction: SUBC
# Format: SUBC A, [HL+B]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:SUBC A, [HL + B] is op16_07 = 0b00110001 & op16_815 = 0b00111011 & A & HL & B {
	A = A - *(&HL + &B) - PSW[0, 1];
}

# Instruction: SUBC
# Format: SUBC A, [HL+C]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:SUBC A, [HL + C] is op16_07 = 0b00110001 & op16_815 = 0b00111010 & A & HL & C {
	A = A - *(&HL + &C) - PSW[0, 1];
}



# Instruction: AND
# Format: AND A, #byte
# Description: Byte Data Subtraction
# Addressing Mode: Register
:AND A, "#"op16_815 is op16_07 = 0b01011101 & op16_815 & A {
	A = A & op16_815;
}

# Instruction: AND
# Format: AND saddr, #byte
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:AND saddr24low, "#"op24_1623 is op24_07 = 0b11011000 & op24_815 >= 0x20 & op24_815 & op24_1623 & saddr24low {
	saddr24low = saddr24low & op24_1623;
}
:AND saddr24high, "#"op24_1623 is op24_07 = 0b11011000 & op24_815 < 0x20 & op24_815 != 0x1E & op24_815 & op24_1623 & saddr24high {
	saddr24high = saddr24high & op24_1623;
}

# Instruction: AND
# Format: AND A, r
# Description: Byte Data Subtraction
# Addressing Mode: Register
:AND A, op16_810_reg is op16_07 = 0b01100001 & op16_1115 = 0b01011 & op16_810 != 0b001 & op16_810_reg & A {
	A = A & op16_810_reg;
}

# Instruction: AND
# Format: AND r, A
# Description: Byte Data Subtraction
# Addressing Mode: Register
:AND op16_810_reg, A is op16_07 = 0b01100001 & op16_1115 = 0b01010 & op16_810_reg & A {
	op16_810_reg = op16_810_reg & A;
}

# Instruction: AND
# Format: AND A, saddr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:AND A, saddr16low is op16_07 = 0b01011110 & op16_815 >= 0x20 & op16_815 & A & saddr16low {
	A = A & saddr16low;
}
:AND A, saddr16high is op16_07 = 0b01011110 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & A & saddr16high {
	A = A & saddr16high;
}

# Instruction: AND
# Format: AND A, !addr16
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:AND A, "!"abs16 is op24_07 = 0b01011000 & op24_815 & op24_1623 & A & abs16 {
	A = A & abs16;
}

# Instruction: AND
# Format: AND A, [HL]
# Description: Logical Product of Byte Data
# Addressing Mode: Register
:AND A, [HL] is op8_full = 0b01011111 & A & HL {
	A = A & *HL;
}

# Instruction: AND
# Format: AND A, [HL+byte]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:AND A, [HL + op16_815] is op16_07 = 0b01011001 & op16_815 & A & HL {
	A = A & *(&HL + op16_815);
}

# Instruction: AND
# Format: AND A, [HL+B]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:AND A, [HL + B] is op16_07 = 0b00110001 & op16_815 = 0b01011011 & A & HL & B {
	A = A & *(&HL + &B);
}

# Instruction: AND
# Format: AND A, [HL+C]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:AND A, [HL + C] is op16_07 = 0b00110001 & op16_815 = 0b01011010 & A & HL & C {
	A = A & *(&HL + &C);
}



# Instruction: OR
# Format: OR A, #byte
# Description: Byte Data Subtraction
# Addressing Mode: Register
:OR A, "#"op16_815 is op16_07 = 0b01101101 & op16_815 & A {
	A = A | op16_815;
}

# Instruction: OR
# Format: OR saddr, #byte
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:OR saddr24low, "#"op24_1623 is op24_07 = 0b11101000 & op24_815 >= 0x20 & op24_815 & op24_1623 & saddr24low {
	saddr24low = saddr24low | op24_1623;
}
:OR saddr24high, "#"op24_1623 is op24_07 = 0b11101000 & op24_815 < 0x20 & op24_815 != 0x1E & op24_815 & op24_1623 & saddr24high {
	saddr24high = saddr24high | op24_1623;
}

# Instruction: OR
# Format: OR A, r
# Description: Byte Data Subtraction
# Addressing Mode: Register
:OR A, op16_810_reg is op16_07 = 0b01100001 & op16_1115 = 0b01101 & op16_810 != 0b001 & op16_810_reg & A {
	A = A | op16_810_reg;
}

# Instruction: OR
# Format: OR r, A
# Description: Byte Data Subtraction
# Addressing Mode: Register
:OR op16_810_reg, A is op16_07 = 0b01100001 & op16_1115 = 0b01100 & op16_810_reg & A {
	op16_810_reg = op16_810_reg | A;
}

# Instruction: OR
# Format: OR A, saddr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:OR A, saddr16low is op16_07 = 0b01101110 & op16_815 >= 0x20 & op16_815 & A & saddr16low {
	A = A | saddr16low;
}
:OR A, saddr16high is op16_07 = 0b01101110 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & A & saddr16high {
	A = A | saddr16high;
}

# Instruction: OR
# Format: OR A, !addr16
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:OR A, "!"abs16 is op24_07 = 0b01101000 & op24_815 & op24_1623 & A & abs16 {
	A = A | abs16;
}

# Instruction: OR
# Format: OR A, [HL]
# Description: Logical Sum of Byte Data
# Addressing Mode: Register
:OR A, [HL] is op8_full = 0b01101111 & A & HL {
	A = A | *HL;
}

# Instruction: OR
# Format: OR A, [HL+byte]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:OR A, [HL + op16_815] is op16_07 = 0b01101001 & op16_815 & A & HL {
	A = A | *(&HL + op16_815);
}

# Instruction: OR
# Format: OR A, [HL+B]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:OR A, [HL + B] is op16_07 = 0b00110001 & op16_815 = 0b01101011 & A & HL & B {
	A = A | *(&HL + &B);
}

# Instruction: OR
# Format: OR A, [HL+C]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:OR A, [HL + C] is op16_07 = 0b00110001 & op16_815 = 0b01101010 & A & HL & C {
	A = A | *(&HL + &B);
}



# Instruction: XOR
# Format: XOR A, #byte
# Description: Byte Data Subtraction
# Addressing Mode: Register
:XOR A, "#"op16_815 is op16_07 = 0b01111101 & op16_815 & A {
	A = A ^ op16_815;
}

# Instruction: XOR
# Format: XOR saddr, #byte
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:XOR saddr24low, "#"op24_1623 is op24_07 = 0b11111000 & op24_815 >= 0x20 & op24_815 & op24_1623 & saddr24low {
	saddr24low = saddr24low ^ op24_1623;
}
:XOR saddr24high, "#"op24_1623 is op24_07 = 0b11111000 & op24_815 < 0x20 & op24_815 != 0x1E & op24_815 & op24_1623 & saddr24high {
	saddr24high = saddr24high ^ op24_1623;
}

# Instruction: XOR
# Format: XOR A, r
# Description: Byte Data Subtraction
# Addressing Mode: Register
:XOR A, op16_810_reg is op16_07 = 0b01100001 & op16_1115 = 0b01111 & op16_810 != 0b001 & op16_810_reg & A {
	A = A ^ op16_810_reg;
}

# Instruction: XOR
# Format: XOR r, A
# Description: Byte Data Subtraction
# Addressing Mode: Register
:XOR op16_810_reg, A is op16_07 = 0b01100001 & op16_1115 = 0b01110 & op16_810_reg & A {
	op16_810_reg = op16_810_reg ^ A;
}

# Instruction: XOR
# Format: XOR A, saddr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:XOR A, saddr16low is op16_07 = 0b01111110 & op16_815 >= 0x20 & op16_815 & A & saddr16low {
	A = A ^ saddr16low;
}
:XOR A, saddr16high is op16_07 = 0b01111110 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & A & saddr16high {
	A = A ^ saddr16high;
}

# Instruction: XOR
# Format: XOR A, !addr16
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:XOR A, "!"abs16 is op24_07 = 0b01111000 & op24_815 & op24_1623 & A & abs16 {
	A = A ^ abs16;
}

# Instruction: XOR
# Format: XOR A, [HL]
# Description: Exclusive Logical Sum of Byte Data
# Addressing Mode: Register
:XOR A, [HL] is op8_full = 0b01111111 & A & HL {
	A = A ^ *HL;
}

# Instruction: XOR
# Format: XOR A, [HL+byte]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:XOR A, [HL + op16_815] is op16_07 = 0b01111001 & op16_815 & A & HL {
	A = A ^ *(&HL + op16_815);
}

# Instruction: XOR
# Format: XOR A, [HL+B]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:XOR A, [HL + B] is op16_07 = 0b00110001 & op16_815 = 0b01111011 & A & HL & B {
	A = A ^ *(&HL + &B);
}

# Instruction: XOR
# Format: XOR A, [HL+C]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:XOR A, [HL + C] is op16_07 = 0b00110001 & op16_815 = 0b01111010 & A & HL & C {
	A = A ^ *(&HL + &C);
}



# Instruction: CMP
# Format: CMP A, #byte
# Description: Byte Data Subtraction
# Addressing Mode: Register
:CMP A, "#"op16_815 is op16_07 = 0b01001101 & op16_815 & A {
	local cmp = op16_815 - A;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (op16_815 < A);
	
	# AC Flag Not Implemented	
}

# Instruction: CMP
# Format: CMP saddr, #byte
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:CMP saddr24low, "#"op24_1623 is op24_07 = 0b11001000 & op24_815 >= 0x20 & op24_815 & op24_1623 & saddr24low {
	local cmp = op24_1623 - saddr24low;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (op24_1623 < saddr24low);
	
	# AC Flag Not Implemented
}
:CMP saddr24high, "#"op24_1623 is op24_07 = 0b11001000 & op24_815 < 0x20 & op24_815 != 0x1E & op24_815 & op24_1623 & saddr24high {
	local cmp = op24_1623 - saddr24high;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (op24_1623 < saddr24high);
	
	# AC Flag Not Implemented
}

# Instruction: CMP
# Format: CMP A, r
# Description: Byte Data Subtraction
# Addressing Mode: Register
:CMP A, op16_810_reg is op16_07 = 0b01100001 & op16_1115 = 0b01001 & op16_810 != 0b001 & op16_810_reg & A {
	local cmp = op16_810_reg - A;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (A < op16_810_reg);
	
	# AC Flag Not Implemented
}

# Instruction: CMP
# Format: CMP r, A
# Description: Byte Data Subtraction
# Addressing Mode: Register
:CMP op16_810_reg, A is op16_07 = 0b01100001 & op16_1115 = 0b01000 & op16_810_reg & A {
	local cmp = A - op16_810_reg;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (op16_810_reg < A);
	
	# AC Flag Not Implemented
}

# Instruction: CMP
# Format: CMP A, saddr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:CMP A, saddr16low is op16_07 = 0b01001110 & op16_815 >= 0x20 & op16_815 & A & saddr16low {
	local cmp = saddr16low - A;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (A < saddr16low);
	
	# AC Flag Not Implemented
}
:CMP A, saddr16high is op16_07 = 0b01001110 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & A & saddr16high {
	local cmp = saddr16high - A;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (A < saddr16high);
	
	# AC Flag Not Implemented
}

# Instruction: CMP
# Format: CMP A, !addr16
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:CMP A, "!"abs16 is op24_07 = 0b01001000 & op24_815 & op24_1623 & A & abs16 {
	local cmp = abs16 - A;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (A < abs16);
	
	# AC Flag Not Implemented
}

# Instruction: CMP
# Format: CMP A, [HL]
# Description: Byte Data Comparison
# Addressing Mode: Register
:CMP A, [HL] is op8_full = 0b01001111 & A & HL {
	local cmp = *HL - A;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (A < *HL);
	
	# AC Flag Not Implemented
}

# Instruction: CMP
# Format: CMP A, [HL+byte]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:CMP A, [HL + op16_815] is op16_07 = 0b01001001 & op16_815 & A & HL {
	local cmp = *(&HL + op16_815) - A;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (A < *(&HL + op16_815));
	
	# AC Flag Not Implemented
}

# Instruction: CMP
# Format: CMP A, [HL+B]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:CMP A, [HL + B] is op16_07 = 0b00110001 & op16_815 = 0b01001011 & A & HL & B {
	local cmp = *(&HL + &B) - A;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (A < *(&HL + &B));
	
	# AC Flag Not Implemented
}

# Instruction: CMP
# Format: CMP A, [HL+C]
# Description: Addition of Byte Data with Carry
# Addressing Mode: Register
:CMP A, [HL + C] is op16_07 = 0b00110001 & op16_815 = 0b01001010 & A & HL & C {
	local cmp = *(&HL + &C) - A;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (A < *(&HL + &C));
	
	# AC Flag Not Implemented
}



## 16-Bit Operation Instructions

# Instruction: ADDW
# Format: ADDW AX, #word
# Description: Addition of Word
# Addressing Mode: Register
:ADDW AX, "#"op24_823_imm16 is op24_07 = 0b11001010 & AX & op24_823_imm16 {
	AX = AX + op24_823_imm16;
}



# Instruction: SUBW
# Format: SUBW AX, #word
# Description: Subtraction of Word
# Addressing Mode: Register
:SUBW AX, "#"op24_823_imm16 is op24_07 = 0b11011010 & AX & op24_823_imm16 {
	AX = AX - op24_823_imm16;
}



# Instruction: CMPW
# Format: CMPW AX, #word
# Description: Comparison of Word
# Addressing Mode: Register
:CMPW AX, "#"op24_823_imm16 is op24_07 = 0b11101010 & AX & op24_823_imm16 {
	local cmp = op24_823_imm16 - AX;
	
	# Set the Z Flag (Comparison)
	PSW[6, 1] = (cmp == 0);
	
	# Set the Carry Flag
	PSW[0, 1] = (AX < op24_823_imm16);
	
	# AC Flag Not Implemented
}



## Multiply/Divide Instructions

# Instruction: MULU
# Format: MULU X
# Description: Multiplication (Unsigned)
# Addressing Mode: Register
:MULU X is op16_07 = 0b00110001 & op16_815 = 0b10001000 & X {
	AX = zext(A) * zext(X);
}


# Instruction: DIVUW
# Format: DIVUW C
# Description: Division of Word (Unsigned)
# Addressing Mode: Register
:DIVUW C is op16_07 = 0b00110001 & op16_815 = 0b10000010 & C {
	AX = AX / zext(C);
	
	# Carry Remainder not implemented.
	#C = sext(AX) % C;
}



## Increment/Decrement Instructions

# Instruction: INC
# Format: INC r
# Description: Byte Data Increment
# Addressing Mode: Register
:INC op8_02_reg is op8_37 = 0b01000 & op8_02_reg {
	op8_02_reg = op8_02_reg + 1;
}

# Instruction: INC
# Format: INC saddr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:INC saddr16low is op16_07 = 0b10000001 & op16_815 >= 0x20 & op16_815 & saddr16low {
	saddr16low = saddr16low + 1;
}
:INC saddr16high is op16_07 = 0b10000001 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & saddr16high {
	saddr16high = saddr16high + 1;
}



# Instruction: DEC
# Format: DEC r
# Description: Byte Data Decrement
# Addressing Mode: Register
:DEC op8_02_reg is op8_37 = 0b01010 & op8_02_reg {
	op8_02_reg = op8_02_reg - 1;
}

# Instruction: DEC
# Format: DEC saddr
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:DEC saddr16low is op16_07 = 0b10010001 & op16_815 >= 0x20 & op16_815 & saddr16low {
	saddr16low = saddr16low - 1;
}
:DEC saddr16high is op16_07 = 0b10010001 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & saddr16high {
	saddr16high = saddr16high - 1;
}



# Instruction: INCW
# Format: INCW rp
# Description: Word Data Increment
# Addressing Mode: Register
:INCW op8_12_reg is op8_37 = 0b10000 & op8_0 = 0b0 & op8_12_reg {
	op8_12_reg = op8_12_reg + 1;
}



# Instruction: DECW
# Format: DECW rp
# Description: Word Data Decrement
# Addressing Mode: Register
:DECW op8_12_reg is op8_37 = 0b10010 & op8_0 = 0b0 & op8_12_reg {
	op8_12_reg = op8_12_reg - 1;
}



## Rotate Instructions

# Instruction: ROR
# Format: ROR A, 1
# Description: Byte Data Rotation to the Right
# Addressing Mode: Register
:ROR A, 1 is op8_full = 0b00100100 & A {
	A = A >> 1;
}



# Instruction: ROL
# Format: ROL A, 1
# Description: Byte Data Rotation to the Left
# Addressing Mode: Register
:ROL A, 1 is op8_full = 0b00100110 & A {
	A = A << 1;
}



# Instruction: RORC
# Format: RORC A, 1
# Description: Byte Data Rotation to the Right with Carry
# Addressing Mode: Register
:RORC A, 1 is op8_full = 0b00100101 & A {
	local carryContents = PSW[0, 1];
	PSW[0, 1] = A[0, 1];
	A[0, 1] = A[1, 1];
	A[1, 1] = A[2, 1];
	A[2, 1] = A[3, 1];
	A[3, 1] = A[4, 1];
	A[4, 1] = A[5, 1];
	A[5, 1] = A[6, 1];
	A[6, 1] = A[7, 1];
	A[7, 1] = carryContents;
}



# Instruction: ROLC
# Format: ROLC A, 1
# Description: Byte Data Rotation to the Left with Carry
# Addressing Mode: Register
:ROLC A, 1 is op8_full = 0b00100111 & A {
	local carryContents = PSW[0, 1];
	PSW[0, 1] = A[7, 1];
	A[7, 1] = A[6, 1];
	A[6, 1] = A[5, 1];
	A[5, 1] = A[4, 1];
	A[4, 1] = A[3, 1];
	A[3, 1] = A[2, 1];
	A[2, 1] = A[1, 1];
	A[1, 1] = A[0, 1];
	A[0, 1] = carryContents;
}



# Instruction: ROR4
# Format: ROR4 [HL]
# Description: Word Data Rotation to the Right with Carry
# Addressing Mode: Register
:ROR4 [HL] is op16_07 = 0b00110001 & op16_815 = 0b10010000 & HL unimpl



# Instruction: ROL4
# Format: ROL4 [HL]
# Description: Word Data Rotation to the Right with Carry
# Addressing Mode: Register
:ROL4 [HL] is op16_07 = 0b00110001 & op16_815 = 0b10000000 & HL unimpl



## BCD Adjust Instructions

# Instruction: ADJBA
# Format: ADJBA
# Description: Word Data Rotation to the Right with Carry
# Addressing Mode: Register
:ADJBA is op16_07 = 0b01100001 & op16_815 = 0b10000000 unimpl



# Instruction: ADJBS
# Format: ADJBS
# Description: Word Data Rotation to the Right with Carry
# Addressing Mode: Register
:ADJBS is op16_07 = 0b01100001 & op16_815 = 0b10010000 unimpl



## Bit Manipulation Instructions

# Instruction: MOV1
# Format: MOV1 CY, saddr.bit
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:MOV1 CY, saddr24low_1623"."op24_1214 is op24_07 = 0b01110001 & op24_811 = 0b0100 & op24_1515 = 0b0 & op24_1623 >= 0x20 & op24_1623 & op24_1214 & CY & saddr24low_1623 unimpl
:MOV1 CY, saddr24high_1623"."op24_1214 is op24_07 = 0b01110001 & op24_811 = 0b0100 & op24_1515 = 0b0 & op24_1623 < 0x20 & op24_1623 != 0x1E & op24_1623 & op24_1214 & CY & saddr24high_1623 unimpl

# Instruction: MOV1
# Format: MOV1 CY, sfrp.bit
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
:MOV1 CY, sfr24_1623"."op24_1214 is op24_07 = 0b01110001 & op24_811 = 0b1100 & op24_1515 = 0b0 & ((op24_815 >= 0x00 & op24_815 <= 0xCF) | (op24_815 >= 0xE0 & op24_815 <= 0xFF)) & op24_815 & op24_1214 & CY & sfr24_1623 unimpl

# Instruction: MOV1
# Format: MOV1 CY,A.bit
# Description: 1 Bit Data Move
:MOV1 CY, A"."op16_1214 is op16_07 = 0b01100001 & op16_811 = 0b1100 & op16_1515 = 0b1 & op16_1214 & CY & A unimpl

# Instruction: MOV1
# Format: MOV1 CY,PSW.bit
# Description: 1 Bit Data Move
:MOV1 CY, PSW"."op24_1214 is op24_07 = 0b01110001 & op24_811 = 0b0100 & op24_1515 = 0b0 & op24_1214 & op24_1623 = 0b00011110 & CY & PSW unimpl

# Instruction: MOV1
# Format: MOV1 CY,[HL].bit
# Description: 1 Bit Data Move
:MOV1 CY, [HL]"."op16_1214 is op16_07 = 0b01110001 & op16_811 = 0b0100 & op16_1515 = 0b1 & op16_1214 & CY & HL unimpl

# Instruction: MOV1
# Format: MOV1 saddr.bit, CY
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:MOV1 saddr24low_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b0001 & op24_1515 = 0b0 & op24_1623 >= 0x20 & op24_1623 & op24_1214 & CY & saddr24low_1623 {
	local mask = PSW[0, 1];
	mask = mask << op24_1214;
	local result = saddr24low_1623:1 | mask;
	saddr24low_1623[0, 8] = result;
}

:MOV1 saddr24high_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b0001 & op24_1515 = 0b0 & op24_1623 < 0x20 & op24_1623 != 0x1E & op24_1623 & op24_1214 & CY & saddr24high_1623 {
	#local location = op24_1214:1;
	#saddr24high_1623[location, 1] = CY;
	#mask:1 = (CY << op24_1214);
	#local result = saddr24high_1623:1 | mask;
	#saddr24high_1623[0, 8] = result;
}

# Instruction: MOV1
# Format: MOV1 sfrp.bit, CY
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
:MOV1 sfr24_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b1001 & op24_1515 = 0b0 & ((op24_815 >= 0x00 & op24_815 <= 0xCF) | (op24_815 >= 0xE0 & op24_815 <= 0xFF)) & op24_815 & op24_1214 & CY & sfr24_1623 unimpl

# Instruction: MOV1
# Format: MOV1 A.bit,CY
# Description: 1 Bit Data Move
:MOV1 A"."op16_1214, CY is op16_07 = 0b01100001 & op16_811 = 0b1001 & op16_1515 = 0b1 & op16_1214 & CY & A unimpl

# Instruction: MOV1
# Format: MOV1 PSW.bit,CY
# Description: 1 Bit Data Move
:MOV1 PSW"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b0001 & op24_1515 = 0b0 & op24_1214 & op24_1623 = 0b00011110 & CY & PSW unimpl

# Instruction: MOV1
# Format: MOV1 [HL].bit,CY
# Description: 1 Bit Data Move
:MOV1 [HL]"."op16_1214, CY is op16_07 = 0b01110001 & op16_811 = 0b0001 & op16_1515 = 0b1 & op16_1214 & CY & HL unimpl



# Instruction: AND1
# Format: AND1 saddr.bit, CY
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:AND1 saddr24low_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b0101 & op24_1515 = 0b0 & op24_1623 >= 0x20 & op24_1623 & op24_1214 & CY & saddr24low_1623 unimpl
:AND1 saddr24high_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b0101 & op24_1515 = 0b0 & op24_1623 < 0x20 & op24_1623 != 0x1E & op24_1623 & op24_1214 & CY & saddr24high_1623 unimpl

# Instruction: AND1
# Format: AND1 sfrp.bit, CY
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
:AND1 sfr24_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b1101 & op24_1515 = 0b0 & ((op24_815 >= 0x00 & op24_815 <= 0xCF) | (op24_815 >= 0xE0 & op24_815 <= 0xFF)) & op24_815 & op24_1214 & CY & sfr24_1623 unimpl

# Instruction: AND1
# Format: AND1 CY,A.bit
# Description: 1 Bit Data Logical Summation
:AND1 CY, A"."op16_1214 is op16_07 = 0b01100001 & op16_811 = 0b1101 & op16_1515 = 0b1 & op16_1214 & CY & A unimpl

# Instruction: AND1
# Format: AND1 CY,PSW.bit
# Description: 1 Bit Data Logical Summation
:AND1 CY, PSW"."op24_1214 is op24_07 = 0b01110001 & op24_811 = 0b0101 & op24_1515 = 0b0 & op24_1214 & op24_1623 = 0b00011110 & CY & PSW unimpl

# Instruction: AND1
# Format: AND1 CY,[HL].bit
# Description: 1 Bit Data Logical Summation
:AND1 CY, [HL]"."op16_1214 is op16_07 = 0b01110001 & op16_811 = 0b0101 & op16_1515 = 0b1 & op16_1214 & CY & HL unimpl



# Instruction: OR1
# Format: OR1 saddr.bit, CY
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:OR1 saddr24low_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b0110 & op24_1515 = 0b0 & op24_1623 >= 0x20 & op24_1623 & op24_1214 & CY & saddr24low_1623 unimpl
:OR1 saddr24high_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b0110 & op24_1515 = 0b0 & op24_1623 < 0x20 & op24_1623 != 0x1E & op24_1623 & op24_1214 & CY & saddr24high_1623 unimpl

# Instruction: OR1
# Format: OR1 sfrp.bit, CY
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
:OR1 sfr24_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b1110 & op24_1515 = 0b0 & ((op24_815 >= 0x00 & op24_815 <= 0xCF) | (op24_815 >= 0xE0 & op24_815 <= 0xFF)) & op24_815 & op24_1214 & CY & sfr24_1623 unimpl

# Instruction: OR1
# Format: OR1 CY,A.bit
# Description: 1 Bit Data Logical Summation
:OR1 CY, A"."op16_1214 is op16_07 = 0b01100001 & op16_811 = 0b1110 & op16_1515 = 0b1 & op16_1214 & CY & A unimpl

# Instruction: OR1
# Format: OR1 CY,PSW.bit
# Description: 1 Bit Data Logical Summation
:OR1 CY, PSW"."op24_1214 is op24_07 = 0b01110001 & op24_811 = 0b0110 & op24_1515 = 0b0 & op24_1214 & op24_1623 = 0b00011110 & CY & PSW unimpl

# Instruction: OR1
# Format: OR1 CY,[HL].bit
# Description: 1 Bit Data Logical Summation
:OR1 CY, [HL]"."op16_1214 is op16_07 = 0b01110001 & op16_811 = 0b0110 & op16_1515 = 0b1 & op16_1214 & CY & HL unimpl



# Instruction: XOR1
# Format: XOR1 saddr.bit, CY
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:XOR1 saddr24low_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b0111 & op24_1515 = 0b0 & op24_1623 >= 0x20 & op24_1623 & op24_1214 & CY & saddr24low_1623 unimpl
:XOR1 saddr24high_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b0111 & op24_1515 = 0b0 & op24_1623 < 0x20 & op24_1623 != 0x1E & op24_1623 & op24_1214 & CY & saddr24high_1623 unimpl

# Instruction: XOR1
# Format: XOR1 sfrp.bit, CY
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
:XOR1 sfr24_1623"."op24_1214, CY is op24_07 = 0b01110001 & op24_811 = 0b1111 & op24_1515 = 0b0 & ((op24_815 >= 0x00 & op24_815 <= 0xCF) | (op24_815 >= 0xE0 & op24_815 <= 0xFF)) & op24_815 & op24_1214 & CY & sfr24_1623 unimpl

# Instruction: XOR1
# Format: XOR1 CY,A.bit
# Description: 1 Bit Data Logical Summation
:XOR1 CY, A"."op16_1214 is op16_07 = 0b01100001 & op16_811 = 0b1111 & op16_1515 = 0b1 & op16_1214 & CY & A unimpl

# Instruction: XOR1
# Format: XOR1 CY,PSW.bit
# Description: 1 Bit Data Logical Summation
:XOR1 CY, PSW"."op24_1214 is op24_07 = 0b01110001 & op24_811 = 0b0111 & op24_1515 = 0b0 & op24_1214 & op24_1623 = 0b00011110 & CY & PSW unimpl

# Instruction: XOR1
# Format: XOR1 CY,[HL].bit
# Description: 1 Bit Data Logical Summation
:XOR1 CY, [HL]"."op16_1214 is op16_07 = 0b01110001 & op16_811 = 0b0111 & op16_1515 = 0b1 & op16_1214 & CY & HL unimpl



# Instruction: SET1
# Format: SET1 saddr.bit
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:SET1 saddr16low"."op16_46 is op16_03 = 0b1010 & op16_7 = 0b0 & op16_815 >= 0x20 & op16_815 & op16_46 & saddr16low {
	mask:1 = (1 << op16_46);
	local result = saddr16low:1 | mask;
	saddr16low[0, 8] = result;
}

:SET1 saddr16high"."op16_46 is op16_03 = 0b1010 & op16_7 = 0b0 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & op16_46 & saddr16high {
	mask:1 = (1 << op16_46);
	local result = saddr16high:1 | mask;
	saddr16high[0, 8] = result;
}

# Instruction: SET1
# Format: SET1 sfrp.bit
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
:SET1 sfr24_1623"."op24_1214 is op24_07 = 0b01110001 & op24_811 = 0b1010 & op24_1515 = 0b0 & ((op24_815 >= 0x00 & op24_815 <= 0xCF) | (op24_815 >= 0xE0 & op24_815 <= 0xFF)) & op24_815 & op24_1214 & sfr24_1623 {
	mask:1 = (1 << op24_1214);
	local result = sfr24_1623:1 | mask;
	sfr24_1623[0, 8] = result;
}

# Instruction: SET1
# Format: SET1 A.bit
# Description: 1 Bit Data Logical Summation
:SET1 A"."op16_1214 is op16_07 = 0b01100001 & op16_811 = 0b1010 & op16_1515 = 0b1 & op16_1214 & A {
	mask:1 = (1 << op16_1214);
	local result = A:1 | mask;
	A = result;
}

# Instruction: SET1
# Format: SET1 PSW.bit
# Description: 1 Bit Data Logical Summation
:SET1 PSW"."op16_46 is op16_7 = 0b0 & op16_03 = 0b1010 & op16_46 & op16_815 = 0b00011110 & PSW {
	mask:1 = (1 << op16_46);
	local result = PSW:1 | mask;
	PSW = result;
}

# Instruction: SET1
# Format: SET1 [HL].bit
# Description: 1 Bit Data Logical Summation
:SET1 [HL]"."op16_1214 is op16_07 = 0b01110001 & op16_811 = 0b0010 & op16_1515 = 0b1 & op16_1214 & HL {
	mask:1 = (1 << op16_1214);
	local result = *:1 HL | mask;
	*HL = result;
}



# Instruction: CLR1
# Format: CLR1 saddr.bit
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:CLR1 saddr16low"."op16_46 is op16_03 = 0b1011 & op16_7 = 0b0 & op16_815 >= 0x20 & op16_815 & op16_46 & saddr16low {
	mask:1 = (1 << op16_46);
	mask = ~mask;
	local result = saddr16low:1 & mask;
	saddr16low[0, 8] = result;
}
:CLR1 saddr16high"."op16_46 is op16_03 = 0b1011 & op16_7 = 0b0 & op16_815 < 0x20 & op16_815 != 0x1E & op16_815 & op16_46 & saddr16high {
	mask:1 = (1 << op16_46);
	mask = ~mask;
	local result = saddr16high:1 & mask;
	saddr16high[0, 8] = result;
}

# Instruction: CLR1
# Format: CLR1 sfrp.bit
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
:CLR1 sfr24_1623"."op24_1214 is op24_07 = 0b01110001 & op24_811 = 0b1011 & op24_1515 = 0b0 & ((op24_815 >= 0x00 & op24_815 <= 0xCF) | (op24_815 >= 0xE0 & op24_815 <= 0xFF)) & op24_815 & op24_1214 & sfr24_1623 {
	mask:1 = (1 << op24_1214);
	mask = ~mask;
	local result = sfr24_1623:1 & mask;
	sfr24_1623[0, 8] = result;
}

# Instruction: CLR1
# Format: CLR1 A.bit
# Description: 1 Bit Data Logical Summation
:CLR1 A"."op16_1214 is op16_07 = 0b01100001 & op16_811 = 0b1011 & op16_1515 = 0b1 & op16_1214 & A {
	mask:1 = (1 << op16_1214);
	mask = ~mask;
	local result = A:1 & mask;
	A = result;
}

# Instruction: CLR1
# Format: CLR1 PSW.bit
# Description: 1 Bit Data Logical Summation
:CLR1 PSW"."op16_46 is op16_7 = 0b0 & op16_03 = 0b1011 & op16_46 & op16_815 = 0b00011110 & PSW {
	mask:1 = (1 << op16_46);
	mask = ~mask;
	local result = PSW:1 & mask;
	PSW = result;
}

# Instruction: CLR1
# Format: CLR1 [HL].bit
# Description: 1 Bit Data Logical Summation
:CLR1 [HL]"."op16_1214 is op16_07 = 0b01110001 & op16_811 = 0b0011 & op16_1515 = 0b1 & op16_1214 & HL {
	mask:1 = (1 << op16_1214);
	mask = ~mask;
	local result = *:1 HL & mask;
	*HL = result;
}



# Instruction: SET1
# Format: SET1 CY
# Description: 1 Bit Data Set
:SET1 CY is op8_full = 0b00100000 & CY {
	PSW[0, 1] = 1;
}



# Instruction: CLR1
# Format: CLR1 CY
# Description: 1 Bit Data Clear
:CLR1 CY is op8_full = 0b00100001 & CY {
	PSW[0, 1] = 0;
}



# Instruction: NOT1
# Format: NOT1 CY
# Description: 1 Bit Data Logical Negation
:NOT1 CY is op8_full = 0b00000001 & CY {
	PSW[0, 1] = !PSW[0, 1];
}



## Calling/Returning Instructions

# Instruction: CALL
# Format: CALL !addr16
# Description: Subroutine Call
# Addressing Mode: Direct Addressing
:CALL "!"abs16 is op24_07 = 0b10011010 & op24_815 & op24_1623 & abs16 {
	call abs16;
}



# Instruction: CALLF
# Format: CALLF !addr16
# Description: Subroutine Call
# Addressing Mode: Direct Addressing
:CALLF "!"addr11 is op16_7 = 0b0 & op16_03 = 0b1100 & op16_46 & op16_815 [addr11 = (0b1 << 11) + (op16_46 << 8) + op16_815;] unimpl



# Instruction: CALLT
# Format: CALLT [addr5]
# Description: Subroutine Call (Refer to the Call Table)
# Addressing Mode: Table Indirect Addressing
:CALLT [addr5] is op8_67 = 0b11 & op8_51_addr & op8_0 = 0b1 [addr5 = (op8_51_addr * 2) + 0x40;] unimpl



# Instruction: BRK
# Format: BRK
# Description: Software Vectored Interrupt
:BRK is op8_full = 0xBF unimpl



# Instruction: RET
# Format: RET
# Description: Return
:RET is op8_full = 0b10101111 {
	return [PC];
}



# Instruction: RETB
# Format: RETB
# Description: Return from Break
:RETB is op8_full = 0b10011111 unimpl



# Instruction: RETI
# Format: RETI
# Description: Return from Interrupt
:RETI is op8_full = 0b10001111 unimpl



## Stack Manipulation Instructions

# Instruction: PUSH
# Format: PUSH PSW
# Description: Push (to Stack)
:PUSH PSW_Ref is op8_full = 0b00100010 & PSW_Ref {
	push16(PSW);
}

# Instruction: PUSH
# Format: PUSH rp
# Description: Push (to Stack)
:PUSH op8_12_reg is op8_37 = 0b10110 & op8_12_reg & op8_0 = 0b1 {
	push16(op8_12_reg);
}



# Instruction: POP
# Format: POP PSW
# Description: Pop (from Stack)
:POP PSW_Ref is op8_full = 0b00100011 & PSW_Ref {
	pop16(PSW);
}

# Instruction: POP
# Format: POP rp
# Description: Pop (from Stack)
:POP op8_12_reg is op8_37 = 0b10110 & op8_12_reg & op8_0 = 0b0 {
	pop16(op8_12_reg);
}



# Instruction: MOVW
# Format: MOVW SP, #word
# Description: Pop (to Stack)
:MOVW SP, "#"op32_1631_imm16 is op32_07 = 0b11101110 & op32_815 = 0b00011100 & SP & op32_1631_imm16 {
	SP = op32_1631_imm16;
}

# Instruction: MOVW
# Format: MOVW SP, AX
# Description: Pop (to Stack)
:MOVW SP, AX is op16_07 = 0b10011001 & op16_815 = 0b00011100 & SP & AX {
	SP = AX;
}

# Instruction: MOVW
# Format: MOVW AX, SP
# Description: Pop (to Stack)
:MOVW AX, SP is op16_07 = 0b10001001 & op16_815 = 0b00011100 & SP & AX {
	AX = SP;
}



## Unconditional Branch Instructions

# Instruction: BR
# Format: BR !addr16
# Description: Unconditional Branch
:BR "!"abs16 is op24_07 = 0b10011011 & op24_815 & op24_1623 & abs16 {
	goto abs16;
}

# Instruction: BR
# Format: BR $addr16
# Description: Unconditional Branch
:BR "$"jdisp8 is op16_07 = 0b11111010 & jdisp8 {
	goto jdisp8;
}

# Instruction: BR
# Format: BR $addr16
# Description: Unconditional Branch
:BR AX is op16_07 = 0b00110001 & op16_815 = 0b10011000 & AX {
	goto AX;
}



## Conditional Branch Instructions

# Instruction: BC
# Format: BC $addr16
# Description: Conditional Branch
:BC "$"jdisp8 is op16_07 = 0b10001101 & jdisp8 {
	if (PSW[0, 1] == 1) goto jdisp8;
}



# Instruction: BNC
# Format: BNC $addr16
# Description: Conditional Branch
:BNC "$"jdisp8 is op16_07 = 0b10011101 & jdisp8 {
	if (PSW[0, 1] == 0) goto jdisp8;
}



# Instruction: BZ
# Format: BZ $addr16
# Description: Conditional Branch
:BZ "$"jdisp8 is op16_07 = 0b10101101 & jdisp8 {
	if (PSW[6, 1] == 0) goto jdisp8;
}



# Instruction: BNZ
# Format: BNZ $addr16
# Description: Conditional Branch
:BNZ "$"jdisp8 is op16_07 = 0b10111101 & jdisp8 {
	if (PSW[6, 1] == 1) goto jdisp8;
}



# Instruction: BT
# Format: BT saddr.bit. $addr16
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:BT saddr24low"."op24_46, "$"jdisp8_1623 is op24_03 = 0b1100 & op24_7 = 0b1 & op24_815 >= 0x20 & op24_815 & op24_46 & jdisp8_1623 & saddr24low {	
	local mask:1 = (1 << op24_46);
	local result = saddr24low:1 | mask;
	if (result == 1) goto jdisp8_1623;
}
:BT saddr24high"."op24_46, "$"jdisp8_1623 is op24_03 = 0b1100 & op24_7 = 0b1 & op24_815 < 0x20 & op24_815 != 0x1E & op24_815 & op24_46 & jdisp8_1623 & saddr24high {
	local mask:1 = (1 << op24_46);
	local result = saddr24high:1 | mask;
	if (result == 1) goto jdisp8_1623;
}

# Instruction: BT
# Format: BT sfr.bit. $addr16
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:BT sfr32_1623"."op32_1214, "$"jdisp8_2431 is op32_07 = 0b00110001 & op32_811 = 0b0110 & op32_1515 = 0b0 & ((op32_1623 >= 0x00 & op32_1623 <= 0xCF) | (op32_1623 >= 0xE0 & op32_1623 <= 0xFF)) & op32_1623 & op32_1214 & jdisp8_2431 & sfr32_1623 {
	local mask:1 = (1 << op32_1214);
	local result = sfr32_1623:1 | mask;
	if (result == 1) goto jdisp8_2431;
}

# Instruction: BT
# Format: BT A.bit,$addr16
# Description: Conditional Branch
:BT A"."op24_1214,"$"jdisp8_1623 is op24_07 = 0b00110001 & op24_811 = 0b1110 & op24_1515 = 0b0 & op24_1214 & jdisp8_1623 & A {
	local mask:1 = (1 << op24_1214);
	local result = A:1 | mask;
	if (result == 1) goto jdisp8_1623;
}

# Instruction: BT
# Format: BT PSW.bit,$addr16
# Description: Conditional Branch
:BT PSW"."op24_46,"$"jdisp8_1623 is op24_7 = 0b1 & op24_03 = 0b1100 & op24_46 & op24_815 = 0b00011110 & jdisp8_1623 & PSW {
	local mask:1 = (1 << op24_46);
	local result = PSW:1 | mask;
	if (result == 1) goto jdisp8_1623;
}

# Instruction: BT
# Format: BT [HL].bit,$addr16
# Description: Conditional Branch
:BT [HL]"."op24_1214,"$"jdisp8_1623 is op24_07 = 0b00110001 & op24_811 = 0b0110 & op24_1515 = 0b1 & op24_1214 & jdisp8_1623 & HL {
	local mask:1 = (1 << op24_1214);
	local result = *:1 HL | mask;
	if (result == 1) goto jdisp8_1623;
}



# Instruction: BF
# Format: BF saddr.bit. $addr16
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:BF saddr32low_1623"."op32_1214, "$"jdisp8_2431 is op32_07 = 0b00110001 & op32_811 = 0b0011 & op32_1515 = 0b0 & op32_1623 >= 0x20 & jdisp8_2431 & op32_1623 & op32_1214 & saddr32low_1623 {
	local mask:1 = (1 << op32_1214);
	local result = saddr32low_1623:1 & mask;
	if (result == 0) goto jdisp8_2431;
}
:BF saddr32high_1623"."op32_1214, "$"jdisp8_2431 is op32_07 = 0b00110001 & op32_811 = 0b0011 & op32_1515 = 0b0 & op32_1623 < 0x20 & op32_1623 != 0x1E & jdisp8_2431 & op32_1623 & op32_1214 & saddr32high_1623 {
	local mask:1 = (1 << op32_1214);
	local result = saddr32high_1623:1 & mask;
	if (result == 0) goto jdisp8_2431;
}

# Instruction: BF
# Format: BF sfr.bit. $addr16
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:BF sfr32_1623"."op32_1214, "$"jdisp8_2431 is op32_07 = 0b00110001 & op32_811 = 0b0111 & op32_1515 = 0b0 & ((op32_1623 >= 0x00 & op32_1623 <= 0xCF) | (op32_1623 >= 0xE0 & op32_1623 <= 0xFF)) & op32_1623 & op32_1214 & jdisp8_2431 & sfr32_1623 {
	local mask:1 = (1 << op32_1214);
	local result = sfr32_1623:1 & mask;
	if (result == 0) goto jdisp8_2431;
}

# Instruction: BF
# Format: BF A.bit,$addr16
# Description: Conditional Branch
:BF A"."op24_1214,"$"jdisp8_1623 is op24_07 = 0b00110001 & op24_811 = 0b1111 & op24_1515 = 0b0 & op24_1214 & jdisp8_1623 & A {
	local mask:1 = (1 << op24_1214);
	local result = A:1 & mask;
	if (result == 0) goto jdisp8_1623;
}

# Instruction: BF
# Format: BF PSW.bit,$addr16
# Description: Conditional Branch
:BF PSW"."op32_1214,"$"jdisp8_2431 is op32_07 = 0b00110001 & op32_811 = 0b0011 & op32_1515 = 0b0 & op32_1214 & op32_1623 = 0b00011110 & jdisp8_2431 & PSW {
	local mask:1 = (1 << op32_1214);
	local result = PSW:1 & mask;
	if (result == 0) goto jdisp8_2431;
}

# Instruction: BF
# Format: BF [HL].bit,$addr16
# Description: Conditional Branch
:BF [HL]"."op24_1214,"$"jdisp8_1623 is op24_07 = 0b00110001 & op24_811 = 0b0111 & op24_1515 = 0b1 & op24_1214 & jdisp8_1623 & HL {
	local mask:1 = (1 << op24_1214);
	local result = *:1 HL & mask;
	if (result == 0) goto jdisp8_1623;
}



# Instruction: BTCLR
# Format: BTCLR saddr.bit. $addr16
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:BTCLR saddr32low_1623"."op32_1214, "$"jdisp8_2431 is op32_07 = 0b00110001 & op32_811 = 0b0001 & op32_1515 = 0b0 & op32_1623 >= 0x20 & jdisp8_2431 & op32_1623 & op32_1214 & saddr32low_1623 {
	local mask:1 = (1 << op32_1214);
	local result = saddr32low_1623:1 | mask;
	
	# Clear the Bit.
	local maskI = ~mask;
	saddr32low_1623 = saddr32low_1623:1 & maskI;
	
	if (result == 1) goto jdisp8_2431;
}
:BTCLR saddr32high_1623"."op32_1214, "$"jdisp8_2431 is op32_07 = 0b00110001 & op32_811 = 0b0001 & op32_1515 = 0b0 & op32_1623 < 0x20 & op32_1623 != 0x1E & jdisp8_2431 & op32_1623 & op32_1214 & saddr32high_1623 {
	local mask:1 = (1 << op32_1214);
	local result = saddr32high_1623:1 | mask;
	
	# Clear the Bit.
	local maskI = ~mask;
	saddr32high_1623 = saddr32high_1623:1 & maskI;
	
	if (result == 1) goto jdisp8_2431;
}

# Instruction: BTCLR
# Format: BTCLR sfr.bit. $addr16
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:BTCLR sfr32_1623"."op32_1214, "$"jdisp8_2431 is op32_07 = 0b00110001 & op32_811 = 0b0101 & op32_1515 = 0b0 & ((op32_1623 >= 0x00 & op32_1623 <= 0xCF) | (op32_1623 >= 0xE0 & op32_1623 <= 0xFF)) & op32_1623 & op32_1214 & jdisp8_2431 & sfr32_1623 {
	local mask:1 = (1 << op32_1214);
	local result = sfr32_1623:1 | mask;
	
	# Clear the Bit.
	local maskI = ~mask;
	sfr32_1623 = sfr32_1623:1 & maskI;
	
	if (result == 1) goto jdisp8_2431;
}

# Instruction: BTCLR
# Format: BTCLR A.bit,$addr16
# Description: Conditional Branch
:BTCLR A"."op24_1214,"$"jdisp8_1623 is op24_07 = 0b00110001 & op24_811 = 0b1101 & op24_1515 = 0b0 & op24_1214 & jdisp8_1623 & A {
	local mask:1 = (1 << op24_1214);
	local result = A:1 | mask;
	
	# Clear the Bit.
	local maskI = ~mask;
	A = A:1 & maskI;
	
	if (result == 1) goto jdisp8_1623;
}

# Instruction: BTCLR
# Format: BTCLR PSW.bit,$addr16
# Description: Conditional Branch
:BTCLR PSW"."op32_1214,"$"jdisp8_2431 is op32_07 = 0b00110001 & op32_811 = 0b0001 & op32_1515 = 0b0 & op32_1214 & op32_1623 = 0b00011110 & jdisp8_2431 & PSW {
	local mask:1 = (1 << op32_1214);
	local result = PSW:1 | mask;
	
	# Clear the Bit.
	local maskI = ~mask;
	PSW = PSW:1 & maskI;
	
	if (result == 1) goto jdisp8_2431;
}

# Instruction: BTCLR
# Format: BTCLR [HL].bit,$addr16
# Description: Conditional Branch
:BTCLR [HL]"."op24_1214,"$"jdisp8_1623 is op24_07 = 0b00110001 & op24_811 = 0b0101 & op24_1515 = 0b1 & op24_1214 & jdisp8_1623 & HL{
	local mask:1 = (1 << op24_1214);
	local result = A:1 | mask;
	
	# Clear the Bit.
	local maskI = ~mask;
	A = A:1 & maskI;
	
	if (result == 1) goto jdisp8_1623;
}

# Instruction: DBNZ
# Format: DBNZ B,$addr16
# Description: Conditional Branch
:DBNZ B,"$"jdisp8 is op16_07 = 0b10001011 & jdisp8 & B {
	B = B - 1;
	if (B != 0) goto jdisp8;
}

# Instruction: DBNZ
# Format: DBNZ C,$addr16
# Description: Conditional Branch
:DBNZ C,"$"jdisp8 is op16_07 = 0b10001010 & jdisp8 & C {
	C = C - 1;
	if (C != 0) goto jdisp8;
}

# Instruction: DBNZ
# Format: DBNZ saddr.bit. $addr16
# Description: Byte Data Transfer
# Addressing Mode: Short Direct
# Note: Condition added here to prevent PSW instruction overlap.
:DBNZ saddr24low, "$"jdisp8_1623 is op24_07 = 0b00000100 & op24_815 >= 0x20 & op24_815 & jdisp8_1623 & saddr24low {
	saddr24low = saddr24low - 1;
	if (saddr24low != 0) goto jdisp8_1623;
}

:DBNZ saddr24high, "$"jdisp8_1623 is op24_07 = 0b00000100 & op24_815 < 0x20 & op24_815 != 0x1E & op24_815 & jdisp8_1623 & saddr24high {
	saddr24high = saddr24high - 1;
	if (saddr24high != 0) goto jdisp8_1623;
}

## CPU Control Instructions

# Instruction: SEL
# Format: SEL RBn
# Description: Select Register Bank
:SEL "RB"RB is op16_07 = 0b01100001 & op16_810 = 0b000 & op16_12 = 0b1 & op16_1415 = 0b11 & op16_11 & op16_13 [RB = (op16_13 << 1) + op16_11;] unimpl

# Instruction: NOP
# Format: NOP
# Description: No Operation
:NOP is op8_full = 0x0 {

}



# Instruction: EI
# Format: EI
# Description: Enable Interrupts
:EI is op16_07 = 0x7A & op16_815 = 0x1E {
	enableInterrupts();
}



# Instruction: DI
# Format: DI
# Description: Disable Interrupts
:DI is op16_07 = 0x7B & op16_815 = 0x1E {
	disableInterrupts();
}



# Instruction: HALT
# Format: HALT
# Description: Halt Processor Operation
:HALT is op16_07 = 0x71 & op16_815 = 0x10 {
	halt();
}



# Instruction: STOP
# Format: STOP
# Description: Stop Processor Operation
:STOP is op16_07 = 0x71 & op16_815 = 0x0 {
	stop();
}